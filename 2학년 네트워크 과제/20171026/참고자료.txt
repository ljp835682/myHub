/*
* echo_selserv_win.c
* Written by SW. YOON
*/

#include <stdio.h>
#include <string.h>
#include <winsock2.h>
#define BUFSIZE 512
#define PLAYERCOUNT 2
#define MAXUSER   10
#define NODATA   -1

enum { NO_WIN, FIRST_WIN, SECOND_WIN = -1 };
enum STATE{ INTRO_SEND, GVALUE_RECV, RESULT_SEND, GAME_OVER, CONNECT_END };
enum PROTOCOL{ INTRO, GVALUE, RESULT };

struct _ClientInfo
{
	SOCKET sock;
	SOCKADDR_IN clientaddr;
	STATE state;
	int	gvalue;
	char  packetbuf[BUFSIZE];
	_ClientInfo* part;
	HANDLE hthread;
};


int who_win(int part1, int part2);
void err_quit(char *msg);
void err_display(char *msg);
int recvn(SOCKET s, char *buf, int len, int flags);

_ClientInfo* AddClient(SOCKET sock, SOCKADDR_IN clientaddr);
void RemoveClient(_ClientInfo* ptr);

bool MatchPartner(_ClientInfo* _ptr);

DWORD CALLBACK ProcessClient(LPVOID);
DWORD CALLBACK WaitClient(LPVOID);
DWORD CALLBACK Dummy(LPVOID);

void AddThread(LPTHREAD_START_ROUTINE process, LPVOID _ptr);
void RemoveThread(int index);

_ClientInfo* ClientInfo[MAXUSER];
HANDLE hThread[MAXUSER];

int count = 0;
int threadcount = 0;

char No_win[] = "비겼습니다.!!";
char win[] = "이겼습니다!!";
char lose[] = "졌습니다!!!!";
char Intro[] = "가위:0, 바위:1, 보:2 를 입력하세요:";

int main(int argc, char **argv)
{
	// 윈속 초기화
	WSADATA wsa;
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
		return -1;

	// socket()
	SOCKET listen_sock = socket(AF_INET, SOCK_STREAM, 0);
	if (listen_sock == INVALID_SOCKET) err_quit("socket()");

	// bind()
	SOCKADDR_IN serveraddr;
	ZeroMemory(&serveraddr, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	serveraddr.sin_port = htons(9000);
	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
	int retval = bind(listen_sock, (SOCKADDR *)&serveraddr, sizeof(serveraddr));
	if (retval == SOCKET_ERROR) err_quit("bind()");

	// listen()
	retval = listen(listen_sock, SOMAXCONN);
	if (retval == SOCKET_ERROR) err_quit("listen()");

	// 데이터 통신에 사용할 변수		
	int addrlen;
	SOCKET sock;
	SOCKADDR_IN clientaddr;
	

	hThread[threadcount++] = CreateThread(nullptr, 0, Dummy, nullptr, 0, nullptr);	
	
	CreateThread(nullptr, 0, WaitClient, nullptr, 0, nullptr);

	while (1)
	{
		addrlen = sizeof(clientaddr);

		sock = accept(listen_sock, (SOCKADDR *)&clientaddr, &addrlen);
		if (sock == INVALID_SOCKET)
		{
			err_display("accept()");
			continue;
		}

		_ClientInfo* ptr = AddClient(sock, clientaddr);

		if (MatchPartner(ptr))
		{
			if (ptr->part->hthread == nullptr)
			{
				AddThread(ProcessClient, ptr->part);				
				TerminateThread(hThread[0], -1);
			}
		}

		AddThread(ProcessClient, ptr);
		TerminateThread(hThread[0], -1);		
	}

	closesocket(listen_sock);

	WSACleanup();
	return 0;
}

void AddThread(LPTHREAD_START_ROUTINE process, LPVOID _ptr)
{
	_ClientInfo* ptr = (_ClientInfo*)_ptr;
	ptr->hthread = CreateThread(NULL, 0, process, ptr, 0, nullptr);
	hThread[threadcount++] = ptr->hthread;
}

void RemoveThread(int index)
{
	int i;
	for (i = index; i < threadcount - 1; i++)
	{
		hThread[i] = hThread[i + 1];
	}

	hThread[i] = nullptr;
	threadcount--;
}

DWORD CALLBACK Dummy(LPVOID)
{
	while (1)
	{
		Sleep(0);
	}

	return 0;
}

DWORD CALLBACK ProcessClient(LPVOID  _ptr)
{
	_ClientInfo* Client_ptr = (_ClientInfo*)_ptr;

	char* result_str = nullptr;
	int size;
	int strsize;
	int protocol;
	int result;
	int retval;

	char* ptr;
	//bool endlflag = false;

	while (1)
	{
		switch (Client_ptr->state)
		{
		case INTRO_SEND:
			ptr = Client_ptr->packetbuf;
			protocol = INTRO;
			strsize = strlen(Intro);
			size = sizeof(protocol)+sizeof(strsize)+strsize;

			memcpy(ptr, &size, sizeof(size));
			ptr = ptr + sizeof(size);

			memcpy(ptr, &protocol, sizeof(protocol));
			ptr = ptr + sizeof(protocol);

			memcpy(ptr, &strsize, sizeof(strsize));
			ptr = ptr + sizeof(strsize);

			memcpy(ptr, Intro, strsize);

			if (send(Client_ptr->sock, Client_ptr->packetbuf, sizeof(int)+size, 0) == SOCKET_ERROR)
			{
				err_display("IntroSend()");
				Client_ptr->state = CONNECT_END;
				return -1;
			}
			else
			{
				Client_ptr->state = GVALUE_RECV;
			}

		case GVALUE_RECV:

			retval = recvn(Client_ptr->sock, (char*)&size, sizeof(size), 0);
			if (retval == SOCKET_ERROR)
			{
				err_display("gvalue recv error()");
				Client_ptr->state = CONNECT_END;
				return -1;

			}
			else if (retval == 0)
			{
				Client_ptr->state = CONNECT_END;
				return 0;
			}

			retval = recvn(Client_ptr->sock, Client_ptr->packetbuf, size, 0);
			if (retval == SOCKET_ERROR)
			{
				err_display("gvalue recv error()");
				Client_ptr->state = CONNECT_END;
				return -1;

			}
			else if (retval == 0)
			{
				Client_ptr->state = CONNECT_END;
				return 0;
			}

			ptr = Client_ptr->packetbuf;
			memcpy(&protocol, ptr, sizeof(protocol));
			ptr = ptr + sizeof(protocol);

			if (protocol == GVALUE)
			{
				memcpy(&Client_ptr->gvalue, ptr, sizeof(Client_ptr->gvalue));
			}

			Client_ptr->state = RESULT_SEND;

		case RESULT_SEND:
			if (Client_ptr->part != nullptr)
			{
				if (Client_ptr->part->gvalue != NODATA)
				{
					result = who_win(Client_ptr->gvalue, Client_ptr->part->gvalue);
					switch (result)
					{
					case FIRST_WIN:
						result_str = win;
						break;
					case SECOND_WIN:
						result_str = lose;
						break;
					case NO_WIN:
						result_str = No_win;
						break;
					}

					ptr = Client_ptr->packetbuf;
					protocol = RESULT;
					strsize = strlen(result_str);
					size = sizeof(protocol)+sizeof(strsize)+strsize;

					memcpy(ptr, &size, sizeof(size));
					ptr = ptr + sizeof(size);

					memcpy(ptr, &protocol, sizeof(protocol));
					ptr = ptr + sizeof(protocol);

					memcpy(ptr, &strsize, sizeof(strsize));
					ptr = ptr + sizeof(strsize);

					memcpy(ptr, result_str, strsize);

					if (send(Client_ptr->sock, Client_ptr->packetbuf, sizeof(int)+size, 0) == SOCKET_ERROR)
					{
						err_display("IntroSend()");
					}

					Client_ptr->state = GAME_OVER;
				}
				else
				{
					Sleep(0);
				}

				if (Client_ptr->state == GAME_OVER)
				{	
					return 0;					
				}				

			}
			else
			{
				return -1;
			}
		}

	}




	return 0;
}

DWORD CALLBACK WaitClient(LPVOID _ptr)
{
	while (1)
	{
		int index = WaitForMultipleObjects(threadcount, hThread, false, INFINITE);
		index -= WAIT_OBJECT_0;
		DWORD threadid;

		if (index == 0)
		{
			hThread[0] = CreateThread(nullptr, 0, Dummy, nullptr, 0, &threadid);
			continue;
		}

		for (int i = 0; i < count; i++)
		{
			HANDLE hthread = nullptr;

			if (ClientInfo[i]->hthread == hThread[index])
			{
				ClientInfo[i]->hthread = nullptr;

				switch (ClientInfo[i]->state)
				{
				case GAME_OVER:			
					RemoveClient(ClientInfo[i]);
					break;
				case RESULT_SEND:		
					
					break;
				case CONNECT_END:
					if (ClientInfo[i]->part != nullptr)
					{

						if (MatchPartner(ClientInfo[i]->part))
						{
							if (ClientInfo[i]->part->hthread == nullptr)
							{
								AddThread(ProcessClient, ClientInfo[i]->part);
							}

							if (ClientInfo[i]->part->part->hthread == nullptr)
							{							
								AddThread(ProcessClient, ClientInfo[i]->part->part);
							}							
							
						}
						else
						{
							ClientInfo[i]->part->part = nullptr;
						}
					}
					RemoveClient(ClientInfo[i]);

					break;
				}

				RemoveThread(index);

				break;
			}
		}

	}
}

bool MatchPartner(_ClientInfo* _ptr)
{
	for (int i = 0; i < count; i++)
	{
		if (_ptr != ClientInfo[i] && ClientInfo[i]->part == nullptr)
		{
			ClientInfo[i]->part = _ptr;
			_ptr->part = ClientInfo[i];
			return true;
		}
	}

	return false;
}

void err_quit(char *msg)
{
	LPVOID lpMsgbuf;
	FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM,
		NULL, WSAGetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPTSTR)&lpMsgbuf, 0, NULL);
	MessageBox(NULL, (LPCTSTR)lpMsgbuf, msg, MB_ICONERROR);
	LocalFree(lpMsgbuf);
	exit(-1);
}

int recvn(SOCKET s, char *buf, int len, int flags)
{
	int received;
	char *ptr = buf;
	int left = len;

	while (left > 0){
		received = recv(s, ptr, left, flags);
		if (received == SOCKET_ERROR)
			return SOCKET_ERROR;
		else if (received == 0)
			break;
		left -= received;
		ptr += received;
	}

	return (len - left);
}

// 소켓 함수 오류 출력
void err_display(char *msg)
{
	LPVOID lpMsgbuf;
	FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM,
		NULL, WSAGetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPTSTR)&lpMsgbuf, 0, NULL);
	printf("[%s] %s", msg, (LPCTSTR)lpMsgbuf);
	LocalFree(lpMsgbuf);
}

int who_win(int part1, int part2)
{
	if (part1 == part2)
		return NO_WIN;
	else if (part1 % 3 == (part2 + 1) % 3)
		return FIRST_WIN;
	else
		return SECOND_WIN;
}



_ClientInfo* AddClient(SOCKET sock, SOCKADDR_IN clientaddr)
{
	_ClientInfo* ptr = new _ClientInfo;
	ZeroMemory(ptr, sizeof(_ClientInfo));
	ptr->sock = sock;
	memcpy(&(ptr->clientaddr), &clientaddr, sizeof(clientaddr));
	ptr->state = INTRO_SEND;
	ptr->gvalue = NODATA;

	ClientInfo[count] = ptr;
	printf("\nClient 접속: IP 주소=%s, 포트 번호=%d\n", inet_ntoa(clientaddr.sin_addr),
		ntohs(clientaddr.sin_port));
	count++;

	return ptr;
}

void RemoveClient(_ClientInfo* ptr)
{
	closesocket(ptr->sock);

	printf("\nClient 종료: IP 주소=%s, 포트 번호=%d\n",
		inet_ntoa(ptr->clientaddr.sin_addr),
		ntohs(ptr->clientaddr.sin_port));

	for (int i = 0; i < count; i++)
	{
		if (ClientInfo[i] == ptr)
		{		
			delete ptr;
			int j;
			for (j = i; j < count - 1; j++)
			{
				ClientInfo[j] = ClientInfo[j + 1];
			}
			ClientInfo[j] = nullptr;
			break;
		}
	}

	count--;
}